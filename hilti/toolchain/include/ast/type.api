// Copyright (c) 2020-2023 by the Zeek Project. See LICENSE for details.

/** Interface for HILTI types. */
class Type(hilti::trait::isType) : hilti::trait::isNode {
    /** Returns true if the type is equivalent to another HILTI type. */
    bool isEqual(const hilti::Type& other) const;

    /**
     * Returns any parameters associated with type. If a type is declared as
     * `T<A,B,C>` this returns a vector of the AST nodes for `A`, `B`, and
     * `C`.
     */
    std::vector<Node> typeParameters() const;

    /**
     * Returns true if all instances of the same type class can be coerced
     * into the current instance, independent of their pararameters. In HILTI
     * source code, this typically corresponds to a type `T<*>`.
     */
    bool isWildcard() const;

    /** Returns the type of an iterator for this type. */
    const optional_ref<const hilti::Type> iteratorType(bool const_) const;

    /** Returns the type of an view for this type. */
    optional_ref<const hilti::Type> viewType() const;

    /** Returns the type of elements the iterator traverse. */
    optional_ref<const hilti::Type> dereferencedType() const;

    /** Returns the type of elements the container stores. */
    optional_ref<const hilti::Type> elementType() const;

    /** Returns any parameters the type expects. */
    hilti::node::Set<type::function::Parameter> parameters() const;

    /** For internal use. Use ``type::isAllocable` instead. */
    bool _isAllocable() const;

    /** For internal use. Use ``type::isSortable` instead. */
    bool _isSortable() const;

    /** For internal use. Use ``type::isIterator` instead. */
    bool _isIterator() const;

    /** For internal use. Use ``type::isParameterized` instead. */
    bool _isParameterized() const;

    /** For internal use. Use ``type::isReferenceType` instead. */
    bool _isReferenceType() const;

    /** For internal use. Use ``type::isMutable` instead. */
    bool _isMutable() const;

    /** For internal use. Use ``type::isRuntimeNonTrivial` instead. */
    bool _isRuntimeNonTrivial() const;

    /** For internal use. Use ``type::isResolved` instead. */
    bool _isResolved(type::ResolvedState* rstate) const;

    /** Internal state managed by derived class. */
    member type::detail::State _state_;

    /** Implements the `Node` interface. */
    hilti::node::Properties properties() const;

    /** Implements the `Node` interface. */
    const std::vector<hilti::Node>& children() const;

    /** Implements the `Node` interface. */
    std::vector<hilti::Node>& children();

    /** Implements the `Node` interface. */
    const Meta& meta() const;

    /** Implements the `Node` interface. */
    void setMeta(Meta m);

    /** Implements the `Node` interface. */
    bool pruneWalk() const;
};
