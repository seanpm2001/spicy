#! /usr/bin/env bash
#
# Auto-generates `hilti/toolchain/include/ast/builder/node-factory.autogen.h`.
#
# This is a helper script that generates a bunch for simple forwarding methods
# that would be tedious to create by hand as a whole. Not sure yet if this is
# some we want to keep long-term. Alternatively, we could just use the initial
# output as a starting point that we then maintain by hand.
#
# Note that this does not run automatically, it needs to be run manually when
# some of the input files change.

function add_namespace {
    gsed -E "s/([ (])$1/\\1$2::$1/g"
}


if [ $# != 1 -a $# != 2 ]; then
    echo "usage: $0 <build-directory> [<compile-db>]"
    exit 1
fi

build=$1
base=$(cd "$(dirname $0)/.." && pwd)
bin=${build}/bin/autogen-builder-api
db=$2

output="${base}/hilti/toolchain/include/ast/builder/node-factory.autogen.h"
root="${base}/hilti/toolchain/include/hilti/ast" # Make sure to include `hilti/` so that it matches with the include path
headers="\
    ${root}/attribute.h \
    ${root}/attribute.h \
    ${root}/ctors \
    ${root}/declarations \
    ${root}/expressions \
    ${root}/function.h \
    ${root}/function.h \
    ${root}/module.h \
    ${root}/operator.h \
    ${root}/statements \
    ${root}/type.h \
    ${root}/types \
"

ignore="${root}/types/auto.h"

# headers="${root}/types/stream.h" # DELETE
# headers="${root}/declarations/global-variable.h" # DELETE

if [ -z "${db}" ]; then
    db="${build}/compile_commands.json"
fi

if [ ! -x "${bin}" ]; then
    echo "error: cannot find builder API binary at ${bin}"
    exit 1
fi

if [ ! -f "${db}" ]; then
    echo "error: cannot find compile database at ${db}"
    exit 1
fi

cat <<EOF >"${output}"
// DO NOT EDIT. This file is automatically generated by $0."
EOF

    # cat /Users/robin/work/spicy/node-rewrite/hilti/toolchain/include/hilti/ast/builder/node-factory.autogen.h.tmp \
find ${headers} -name '*.h' -type f -not -name 'all.h' \
    | grep -vf <(echo "${ignore}") \
    | xargs -n 1 -P $(nproc) "${bin}" -p "${db}" \
    | add_namespace "Linkage" "declaration" \
    | add_namespace "Flavor" "type::function" \
    | add_namespace "function::Flavor" "type" \
    | add_namespace "Case" "statement::switch_" \
    | add_namespace "switch_::Cases" "statement" \
    | add_namespace "Kind" "expression::keyword" \
    | add_namespace "keyword::Kind" "expression" \
    | add_namespace "parameter::Kind" "declaration" \
    | add_namespace "tuple::Elements" "ctor" \
    | add_namespace "map::Elements" "ctor" \
    | add_namespace "Fields" "type::struct_" \
    | add_namespace "struct_::Fields" "ctor" \
    | add_namespace "try_::Catches" "statement" \
    | add_namespace "enum_::Labels" "type" \
    | add_namespace "comment::Separator" "statement" \
    | add_namespace "assert::Exception" "statement" \
    | add_namespace "AnonymousStruct" "type::Struct" \
    | add_namespace "AnonymousUnion" "type::Union" \
    | add_namespace "switch_::Default" "statement" \
    | add_namespace "Wildcard" "type" \
    | sort | uniq >"${output}"
